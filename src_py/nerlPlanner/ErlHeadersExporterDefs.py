from collections import OrderedDict

# Generates automated Erlang code!

class Comment():
    def __init__(self, comment : str) -> None:
        self.comment = comment

    def generate_code(self):
        return f'% {self.comment}\n'

class AutoGeneratedHeader:
    def __init__(self) -> None:
        pass

    def generate_code(self):
        return f'% This is an auto generated .hrl file\n'

class ModuleName:
    def __init__(self, module_name: str = '') -> None:
        self.module_name = module_name
    
    def generate_code(self):
        return f'-module({self.module_name}).\n '

class Record:
    def __init__(self, record_name : str, in_ordered_dict : OrderedDict, all_caps : bool = False, prefix = '') -> None:
        self.record_name = record_name.lower()
        self.ordered_dict = in_ordered_dict
        self.prefix = prefix
        self.all_caps = all_caps

    def generate_code(self):
        code = f'-record({self.record_name}'+'{'
        last_key = list(self.ordered_dict.keys())[-1].upper() if self.all_caps else list(self.ordered_dict.keys())[-1]
        for key, value in self.ordered_dict.items():
            key = key.upper() if self.all_caps else key
            code += f'{self.prefix}_{key} = {value}'
            code += ',' if last_key != key else ''
        return code.replace('-','_') + '}).\n'

class Definition:
    def __init__(self, macro, value : str ) -> None:
        self.macro = macro
        self.value = value
    
    def force_atom_value(value : str):
        # validates that first letter is lower case which is required by atoms in Erlang
        return value[0].lower() + value[1:] if value else value
    
    def assert_not_atom(value : str):
        if value:
            assert value[0].islower(), f'Value {value} is not an Erlang atom'
        else:
            raise 'Erlang atom cannot be None or empty string!'
        return value

    def generate_code(self):
        return f'-define({self.macro},{self.value}).\n'